/*
 *    Copyright 2023 The ChampSim Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <cstring>
#include <vector>
#include <cassert>
#include <cstdint>
#include <unordered_map>
#include <set>
#include <iomanip>
#include <byteswap.h>
#include <limits.h>
#include <map> 

#include "../../../inc/trace_instruction.h"
#include "disas.hh"
#include "tracereader.hh"

using trace_instr_format = input_instr;

#define CTE_NO_REG  0   /* No register is changed. */
#define CTE_GPR     1   /* GPR change (val2) */
#define CTE_LD_GPR  2   /* Load into GPR (val2) from address (val1) */
#define CTE_ST_GPR  3   /* Store from GPR (val2) to address (val1) */
#define CTE_CAP     11  /* Cap change (val2,val3,val4,val5) */
#define CTE_LD_CAP  12  /* Load Cap (val2,val3,val4,val5) from addr (val1) */
#define CTE_ST_CAP  13  /* Store Cap (val2,val3,val4,val5) to addr (val1) */
#define CTE_EXCEPTION_NONE 31

typedef struct {
    uint8_t entry_type;
//    uint8_t exception;
//    uint16_t cycles;
    uint32_t inst;
    uint64_t pc;
    uint64_t val1;
    uint64_t val2;
    uint64_t val3;
    uint64_t val4;
    uint64_t val5;
//    uint8_t thread;
//    uint8_t asid;
} __attribute__((packed)) cheri_trace_entry_t;


void print_usage(const char* program_name) {
    std::cerr << "CHERI-QEMU Trace to ChampSim Converter\n";
    std::cerr << "===========================================\n";
    std::cerr << "Usage: " << program_name << " <input_trace> <output_trace> \n\n";
    std::cerr << "Arguments:\n";
    std::cerr << "  <input_trace>                               Path to the binary CHERI-QEMU trace file\n";
    std::cerr << "  <output_trace>                              Path for the output ChampSim-compatible trace file\n";
    std::cerr << "Optional arguments:\n";
    std::cerr << "  -v                                          Enable verbose output to stdout\n";
    std::cerr << "  -n <num_simpoints> <instructions_per_simpoint>  Generate separate trace files for each simpoint\n\n";
    std::cerr << "Note: This converter is specifically designed for baseline RISC-V traces\n";
    std::cerr << "      generated by CHERI-QEMU. This tool does NOT support the cheri extension.\n";
}


std::map<uint64_t, bool> code_pages, data_pages;
std::map<uint64_t, uint64_t> remapped_pages;
uint64_t bump_page = 0x1000;

// Function to transform data addresses that collide with code pages
uint64_t transform(uint64_t address)
{
    static int num_allocs = 0;
    uint64_t page = address >> 12;
    uint64_t new_page = page;
    
    // Check if this data address is on a code page
    if (code_pages.find(page) != code_pages.end()) {
        // Check if we've already remapped this page
        if (remapped_pages.find(page) != remapped_pages.end()) {
            new_page = remapped_pages[page];
        } else {
            // Need to allocate a new page for this data
            num_allocs++;
            if (num_allocs % 100 == 0) {
                std::cerr << "[" << num_allocs << " remapped pages]";
                std::cerr.flush();
            }
            
            // Find an unused page
            new_page = bump_page;
            while (code_pages.find(new_page) != code_pages.end() || 
                   data_pages.find(new_page) != data_pages.end()) {
                new_page++;
            }
            bump_page = new_page + 1;
            remapped_pages[page] = new_page;
        }
    }
    
    // Reconstruct address with new page number
    return (new_page << 12) | (address & 0xfff);
}

uint8_t get_instruction_length(uint32_t inst) {
    if ((inst & 0x3) != 0x3) {
        return 2;  // Compressed instruction
    } else {
        return 4;  // Standard 32-bit instruction
    }
}

bool preprocess_trace(const std::string& input_file) {
    std::cerr << "Preprocessing trace to identify code and data pages...\n";
    std::cerr.flush();
    
    auto input = create_input_stream(input_file);
    if (!input || !input->is_open()) {
        std::cerr << "Error: Cannot open input file for preprocessing\n";
        return false;
    }
    
    cheri_trace_entry_t entry;
    uint64_t count = 0;
    
    while (input->read(reinterpret_cast<char*>(&entry), sizeof(cheri_trace_entry_t))) {
        entry.pc = bswap_64(entry.pc);
        entry.val1 = bswap_64(entry.val1);
        
        // Mark code page (from PC)
        code_pages[entry.pc >> 12] = true;
        
        // Mark data pages (from memory accesses)
        if (entry.entry_type == CTE_LD_GPR || entry.entry_type == CTE_ST_GPR ) 
            data_pages[entry.val1 >> 12] = true;
        
        
        count++;
        if (count % 100000000 == 0) {
            std::cerr << ".";
            std::cerr.flush();
            if (count % 600000000 == 0) {
                std::cerr << "\n";
                std::cerr.flush();
            }
        }
    }
    
    input->close();
    std::cerr << "\nFound " << code_pages.size() << " code pages and " 
              << data_pages.size() << " data pages\n";
    std::cerr.flush();
    
    return true;
}

struct InstructionTrace {
    BranchType branch_type = NOT_BRANCH;
    trace_instr_format curr_instr;
    rv_decode decoded_instr;
    inst_type_t type = INST_TYPE_UNKNOWN;
    bool is_ld = false;
    bool is_st = false;


    InstructionTrace() {
        memset(&curr_instr, 0, sizeof(trace_instr_format));
    }

    const char* RiscvBranchType_to_str() const {
        switch(branch_type) {
            case BRANCH_DIRECT_JUMP : return "Branch Direct Jump"; //gg
            case BRANCH_INDIRECT : return "Branch Indirect"; //gg 
            case BRANCH_CONDITIONAL : return "Branch Conditional"; //gg
            case BRANCH_DIRECT_CALL : return "Branch Direct Call"; //gg
            case BRANCH_INDIRECT_CALL : return "Branch Indirect Call"; //gg
            case BRANCH_RETURN : return "Branch Return"; //gg
            case BRANCH_OTHER : return "Branch Other";
            case NOT_BRANCH : return "Not a Branch";
            case ERROR : assert(false); //shouldn't end up here...
        }
        return "";
    }

    void debug_print_instruction() const {

        std::cerr << "\n=== Instruction Debug ==="
         << "\nPC: 0x" << std::hex << curr_instr.ip
         << "\nInstruction: 0x" << std::hex << decoded_instr.inst 
         << "\nInstruction Type: " << inst_type_to_str(type);

        if (curr_instr.is_branch) {
            std::cerr << "\nBranch Type: " << RiscvBranchType_to_str()
            << "\nBranch Taken: " << (int)curr_instr.branch_taken;
        }

        std::cerr << "\n\nDestination Registers\n";
        for (const auto& regs : curr_instr.destination_registers) {
            if (regs)
                std::cerr << "Register ID " << std::dec << static_cast<int>(regs) <<  "\n";   
        }
        
        std::cerr << "\nSource Registers:\n";
        for (const auto& regs : curr_instr.source_registers) {
            if (regs)
                std::cerr << "Register ID " << std::dec << static_cast<int>(regs) << "\n";      
        }
        
        std::cerr << "\n\nMemory Operands";
        std::cerr << "\nDestination Memory:\n";
        for (const auto& mem : curr_instr.destination_memory) {
            if (mem)
                std::cerr << "Memory Address: 0x" << std::hex << mem << "\n";    
        }
        
        std::cerr << "\nSource Memory:\n";
        for (const auto& mem : curr_instr.source_memory) {
            if (mem)
                std::cerr << "Memory Address: 0x" << std::hex << mem << "\n";  
        }
    }
};


uint8_t remap_regid(uint8_t reg, InstructionTrace& trace) {
    //mapping to new register IDs
    const char TRANSLATED_REG_IP = 64;
    const char TRANSLATED_REG_SP = 65;
    const char TRANSLATED_REG_FLAGS = 66;
    const char TRANSLATED_REG_ZERO = 67;

    switch (reg) {
        case rv_ireg_zero: return (trace.type == INST_TYPE_FP) ? TRANSLATED_REG_ZERO : rv_ireg_zero;
        case rv_ireg_sp: return champsim::REG_STACK_POINTER;
        case champsim::REG_STACK_POINTER: return TRANSLATED_REG_SP;
        case champsim::REG_FLAGS: return TRANSLATED_REG_FLAGS;
        case champsim::REG_INSTRUCTION_POINTER: return TRANSLATED_REG_IP;
        default: return reg;
    }
}

BranchType get_branch_type(const rv_decode& dec)
{
    switch (dec.op) {
        // Standard branch instructions
        case rv_op_beq:
        case rv_op_bne:
        case rv_op_blt:
        case rv_op_bge:
        case rv_op_bltu:
        case rv_op_bgeu:
        // Pseudo branch instructions
        case rv_op_beqz:
        case rv_op_bnez:
        case rv_op_blez:
        case rv_op_bgez:
        case rv_op_bltz:
        case rv_op_bgtz:
        case rv_op_ble:
        case rv_op_bleu:
        case rv_op_bgt:
        case rv_op_bgtu:
        // Compressed branches
        case rv_op_c_beqz:
        case rv_op_c_bnez:
            return BRANCH_CONDITIONAL;
        // Jump and link instructions
        case rv_op_j:
        case rv_op_c_j:
        case rv_op_jal:
        case rv_op_c_jal:
            return (dec.rd == rv_ireg_zero) ? BRANCH_DIRECT_JUMP : BRANCH_DIRECT_CALL;
        
        case rv_op_jalr:
        case rv_op_c_jalr:
            if (dec.rd == rv_ireg_zero)   
                return (dec.rs1 == rv_ireg_ra) ? BRANCH_RETURN : BRANCH_INDIRECT;
            else return BRANCH_INDIRECT_CALL;

        // Pseudo jump instructions
        case rv_op_jr:
        case rv_op_c_jr:
            return (dec.rs1 == rv_ireg_ra) ? BRANCH_RETURN : BRANCH_INDIRECT;
        case rv_op_ret:
            return BRANCH_RETURN;

        case rv_op_cjalr:
            assert(false); //cheri extension not supported

        default: return ERROR;
    }
    assert(false); //shouldn't end up here.
}


void set_branch_data(InstructionTrace& trace, cheri_trace_entry_t& entry){

    switch (trace.branch_type)
    {
        case BRANCH_DIRECT_JUMP: //writes ip only
            trace.curr_instr.destination_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.branch_taken = true;
            break;

        case BRANCH_INDIRECT: //writes ip and reads other
            trace.curr_instr.branch_taken = true;
            trace.curr_instr.destination_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);
            break;

        case BRANCH_CONDITIONAL: //writes ip, reads ip and reads other
            trace.curr_instr.destination_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.source_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.source_registers[1] = remap_regid(trace.decoded_instr.rs1, trace);
            if (trace.decoded_instr.rs2 != rv_ireg_zero)
                trace.curr_instr.source_registers[2] = remap_regid(trace.decoded_instr.rs2, trace);
            break;

        case BRANCH_DIRECT_CALL: //reads ip, writes ip: jal ra, offset
            trace.curr_instr.branch_taken = true;
            trace.curr_instr.destination_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.destination_registers[1] = remap_regid(trace.decoded_instr.rd, trace);
            trace.curr_instr.source_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            break;

        case BRANCH_INDIRECT_CALL: //reads ip, writes ip and reads other jalr ra, rs1, imm
            trace.curr_instr.branch_taken = true;
            trace.curr_instr.destination_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.destination_registers[1] = remap_regid(trace.decoded_instr.rd, trace);
            trace.curr_instr.source_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.source_registers[1] = remap_regid(trace.decoded_instr.rs1, trace);
            break;
        
        case BRANCH_RETURN: // writes ip, reads other
            trace.curr_instr.branch_taken = true;
            trace.curr_instr.destination_registers[0] = champsim::REG_INSTRUCTION_POINTER;
            trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);
            break;

        case BRANCH_OTHER:
        case NOT_BRANCH:
        default: 
            assert(false && "Error: Unrecognized branch type\n");
    }
}

void set_mem_data(InstructionTrace& trace, cheri_trace_entry_t& entry) {

    uint8_t access_size = get_memory_access_size(trace.decoded_instr);
    uint64_t address = transform(entry.val1);

    uint64_t cacheline_access_ini = address & ~63lu; //0xffffffffffffffc0
    uint64_t cacheline_access_end = (address + access_size -1) & ~63lu;
 
    if (trace.is_ld) {
        trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
        trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);
        trace.curr_instr.source_memory[0] = address;

        if (cacheline_access_end != cacheline_access_ini)
            trace.curr_instr.source_memory[1] = cacheline_access_end;

    } else if (trace.is_st) {
        trace.curr_instr.source_registers[0]= remap_regid(trace.decoded_instr.rs1, trace);
        trace.curr_instr.source_registers[1] = remap_regid(trace.decoded_instr.rs2, trace);
        trace.curr_instr.destination_memory[0] = address;    

        if (cacheline_access_end != cacheline_access_ini)
            trace.curr_instr.destination_memory[1] = cacheline_access_end;
    }
}


void set_reg_data(InstructionTrace& trace, cheri_trace_entry_t& entry)       
{
    int num_regs_used = count_register_operands(trace.decoded_instr.codec);
    assert(num_regs_used != 0 &&  num_regs_used != 55);

    switch (num_regs_used)
    {
        case 1:
            trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
            break;

        case 2:
            trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
            trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);        
            break;

        case 3:
            trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
            trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);
            trace.curr_instr.source_registers[1] = remap_regid(trace.decoded_instr.rs2, trace);
            break;

        case 4:
            trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
            trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);
            trace.curr_instr.source_registers[1] = remap_regid(trace.decoded_instr.rs2, trace);
            trace.curr_instr.source_registers[2] = remap_regid(trace.decoded_instr.rs3, trace);
            break;

        default:
            assert(false);
    }
}

void set_atomic_data(InstructionTrace& trace, cheri_trace_entry_t& entry)
{  
    uint8_t access_size = get_memory_access_size(trace.decoded_instr);
    uint64_t address = transform(entry.val1);

    uint64_t cacheline_access_ini = address & ~63lu; //0xffffffffffffffc0
    uint64_t cacheline_access_end = (address + access_size -1) & ~63lu;


    switch (trace.type)
    {
    //atomic memory operations
    case INST_TYPE_AMO:
        trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
        trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs2, trace);
        trace.curr_instr.source_registers[1] = remap_regid(trace.decoded_instr.rs1, trace);
        trace.curr_instr.destination_memory[0] = address;
        trace.curr_instr.source_memory[0] = address;

        if (cacheline_access_end != cacheline_access_ini) {
            trace.curr_instr.destination_memory[1] = cacheline_access_end;
            trace.curr_instr.source_memory[1] = cacheline_access_end;
        }
        break;

    case INST_TYPE_AMO_LOAD: 
        trace.curr_instr.destination_registers[0] = remap_regid(trace.decoded_instr.rd, trace);
        trace.curr_instr.source_registers[0] = remap_regid(trace.decoded_instr.rs1, trace);
        trace.curr_instr.source_memory[0] = address;
        
        if (cacheline_access_end != cacheline_access_ini) 
            trace.curr_instr.source_memory[1] = cacheline_access_end;

        break;

    case INST_TYPE_AMO_STORE:
        trace.curr_instr.destination_registers[0] = trace.decoded_instr.rd;
        trace.curr_instr.source_registers[0] = trace.decoded_instr.rs1;
        trace.curr_instr.source_registers[1] = trace.decoded_instr.rs2;

        if (entry.val2 == 0) { //successful write 
            trace.curr_instr.destination_memory[0] = address;
             if (cacheline_access_end != cacheline_access_ini) 
                trace.curr_instr.destination_memory[1] = cacheline_access_end;
        }
        break;
    default: 
        assert(false);
    }
}

void convert_cheri_trace_entry(cheri_trace_entry_t& entry, InstructionTrace& trace)
{
    trace.decoded_instr = disasm_inst(rv64, entry.pc, entry.inst, 0);
    trace.curr_instr.ip = entry.pc;
    trace.type = classify_instruction(trace.decoded_instr);
    trace.curr_instr.is_branch = trace.type == INST_TYPE_BRANCH;

    assert(trace.decoded_instr.op != rv_op_illegal); 
    if (trace.type == INST_TYPE_UNKNOWN) {
        printf("Error: Unknown instruction 0x%08lx detected at ip 0x%08lx\n", trace.decoded_instr.inst, trace.decoded_instr.pc);
        assert(false);
    }

    switch (trace.type)
    {
        case INST_TYPE_BRANCH:
            trace.branch_type = get_branch_type(trace.decoded_instr);
            assert(trace.branch_type != ERROR);
            set_branch_data(trace, entry);
            break;

        case INST_TYPE_LOAD:
        case INST_TYPE_CAP_LOAD:
        case INST_TYPE_FP_LOAD:
            trace.is_ld = true;
            set_mem_data(trace,entry);
            break;
            
        case INST_TYPE_STORE:
        case INST_TYPE_CAP_STORE: 
        case INST_TYPE_FP_STORE:
            trace.is_st = true;
            set_mem_data(trace,entry);
            break;

        case INST_TYPE_CAP_OP:
        case INST_TYPE_ALU:        
        case INST_TYPE_CSR:
        case INST_TYPE_FP:
            set_reg_data(trace, entry);
            break;

        case INST_TYPE_AMO:
        case INST_TYPE_AMO_LOAD:
        case INST_TYPE_AMO_STORE:
            set_atomic_data(trace,entry);
            break;

        case INST_TYPE_SYSTEM: //usually fence instructions with no register operands
            break;
        case INST_TYPE_UNKNOWN:
        default:
            assert(false);       
    }  
}

int main(int argc, char** argv) {
    if (argc < 3) {
        print_usage(argv[0]);
        return 1;
    }
    
    std::string input_file = argv[1];
    std::string base_output_file = argv[2];
    bool verbose = false, simpoint_mode = false;
    uint64_t num_simpoints = 0;
    uint64_t instructions_per_simpoint = 0;
    
    // Parse command line arguments
    for (int i = 1; i < argc; i++) {
        if(strcmp(argv[i], "-v") == 0) {
            verbose = true;
        } else if (strcmp(argv[i],"-n") == 0) {
            if (i + 2 < argc) {
                simpoint_mode = true;
                num_simpoints = std::strtoull(argv[i+1], nullptr, 10);
                instructions_per_simpoint = std::strtoull(argv[i+2], nullptr, 10);
                i += 2;  
            } else {
                std::cerr << "Error: -n flag requires num_simpoints and instructions_per_simpoint\n";
                return 1;
            }
        }
    }
    
    if (simpoint_mode) {
        if (num_simpoints == 0 || instructions_per_simpoint == 0) {
            std::cerr << "Error: num_simpoints and instructions_per_simpoint must be greater than 0\n";
            return 1;
        }
        std::cerr << "Simpoint mode enabled: " << num_simpoints << " simpoints, " 
                  << instructions_per_simpoint << " instructions per simpoint\n";
    }


    if (!preprocess_trace(input_file)) {
        return 1;
    }

    // Extract base name for output files (remove .champsimtrace or similar extension)
    std::string base_name = base_output_file;
    size_t dot_pos = base_name.rfind('.');
    if (dot_pos != std::string::npos) {
        base_name = base_name.substr(0, dot_pos);
    }

    // Open first output file
    std::ofstream output;
    std::string current_output_file;

    if (simpoint_mode) {
        current_output_file = base_name + "-simpoint-0.champsimtrace";
        output.open(current_output_file, std::ios::binary);
        if (!output) {
            std::cerr << "Error: Cannot open output file " << current_output_file << std::endl;
            return 1;
        }
        if (verbose) {
            std::cerr << "Starting file: " << current_output_file << std::endl;
        }
    } else {
        output.open(base_output_file, std::ios::binary);
        if (!output) {
            std::cerr << "Error: Cannot open output file " << base_output_file << std::endl;
            return 1;
        }
    }
    
    std::cerr << "Converting trace...\n";
    std::cerr.flush();

    auto input = create_input_stream(input_file);
    if (!input || !input->is_open()) {
        std::cerr << "Error: Cannot open input file " << input_file << std::endl;
        return 1;
    }

    
    cheri_trace_entry_t entry;
    InstructionTrace trace, prev_trace;
    uint64_t instruction_count = 0;
    uint64_t current_file_instructions = 0;
    bool pending_instr = false;
    size_t current_simpoint_idx = 0;
    
    while (input->read(reinterpret_cast<char*>(&entry), sizeof(cheri_trace_entry_t))) {
        entry.pc = bswap_64(entry.pc);
        entry.val1 = bswap_64(entry.val1);
        entry.val2 = bswap_64(entry.val2);
        entry.val3 = bswap_64(entry.val3);
        entry.val4 = bswap_64(entry.val4);
        entry.val5 = bswap_64(entry.val5);
        entry.inst = bswap_32(entry.inst);


        // Process current entry
        trace = InstructionTrace();
        convert_cheri_trace_entry(entry, trace);
        
        if (pending_instr) {
            // Handle conditional branch taken/not taken
            if (prev_trace.branch_type == BRANCH_CONDITIONAL) {
                uint64_t fall_through_pc = prev_trace.curr_instr.ip + get_instruction_length(prev_trace.decoded_instr.inst);
                prev_trace.curr_instr.branch_taken = (entry.pc != fall_through_pc);
            }
            
            // Check if we need to switch files BEFORE writing
            if (simpoint_mode && current_file_instructions >= instructions_per_simpoint && current_simpoint_idx < num_simpoints - 1) {
                output.close();
                
                if (verbose) {
                    std::cerr << "Completed simpoint " << current_simpoint_idx 
                              << " with " << current_file_instructions << " instructions" << std::endl;
                }
                
                current_simpoint_idx++;
                
                if (current_simpoint_idx < num_simpoints) {
                    current_output_file = base_name + "-simpoint-" + std::to_string(current_simpoint_idx) + ".champsimtrace";
                    output.open(current_output_file, std::ios::binary);
                    
                    if (!output) {
                        std::cerr << "Error: Cannot open output file " << current_output_file << std::endl;
                        input->close();
                        return 1;
                    }
                    
                    if (verbose) {
                        std::cerr << "Starting file: " << current_output_file << std::endl;
                    }
                    
                    current_file_instructions = 0;
                } else {
                    // No more simpoints
                    if (verbose) {
                        std::cerr << "All simpoints processed" << std::endl;
                    }
                    break;
                }
            }
            
            // Write instruction if we still have an open file
            if (output.is_open()) {
                output.write(reinterpret_cast<const char*>(&prev_trace.curr_instr), sizeof(trace_instr_format));
                current_file_instructions++;
                
                if (verbose) {
                    prev_trace.debug_print_instruction();
                }
            }
        }
        
        prev_trace = trace;
        pending_instr = true;
        instruction_count++;
    }
    
    // Handle the last pending instruction
    if (pending_instr && output.is_open() && (!simpoint_mode || current_file_instructions < instructions_per_simpoint)) {
        output.write(reinterpret_cast<const char*>(&trace.curr_instr), sizeof(trace_instr_format));
        current_file_instructions++;
    }
    
    input->close();
    if (output.is_open()) {
        output.close();
        if (verbose && simpoint_mode) {
            std::cerr << "Final simpoint " << current_simpoint_idx 
                      << " with " << current_file_instructions << " instructions" << std::endl;
        }
    }
    
    std::cerr << "\nConversion complete!\n";
    std::cerr << "Processed " << instruction_count << " total instructions.\n";
    std::cerr << "Remapped " << remapped_pages.size() << " data pages to avoid code/data conflicts.\n";
    if (simpoint_mode) {
        std::cerr << "Created " << std::min(current_simpoint_idx + 1, num_simpoints) << " simpoint trace files.\n";
    }
    return 0;
}